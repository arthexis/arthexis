{% extends "admin/base_site.html" %}
{% load i18n admin_urls %}

{% block breadcrumbs %}
{% if has_permission %}
<div class="breadcrumbs">
  <a href="{% url 'admin:index' %}">{% trans 'Home' %}</a>
  &rsaquo; <a href="{% url 'admin:app_list' app_label=opts.app_label %}">{{ opts.app_config.verbose_name|capfirst }}</a>
  &rsaquo; <a href="{% url opts|admin_urlname:'changelist' %}">{{ opts.verbose_name_plural|capfirst }}</a>
  &rsaquo; {% trans "Register Visitor Node" %}
</div>
{% endif %}
{% endblock %}

{% block content %}
<div id="content-main">
  <p>{% trans "Attempting to exchange node information between this host and the visiting instance." %}</p>
  <ul>
      <li id="host-result">{% trans "Registering the visiting node on this server…" %}</li>
      <li id="visitor-result">{% trans "Registering this server on the visiting node…" %}</li>
  </ul>
  <p id="result"></p>
</div>
<script>
(function() {
    const token = "{{ token|escapejs }}";
    const hostInfoUrl = "{{ info_url|escapejs }}?token=" + token;
    const hostRegisterUrl = "{{ register_url|escapejs }}";
    const visitorInfoUrl = "{{ visitor_info_url|escapejs }}";
    const visitorRegisterUrl = "{{ visitor_register_url|escapejs }}";
    const hostResult = document.getElementById("host-result");
    const visitorResult = document.getElementById("visitor-result");
    const summary = document.getElementById("result");
    const messages = {
        hostRegistered: "{{ _('Visitor node registered with this server.')|escapejs }}",
        visitorRegistered: "{{ _('Host node registered with visitor.')|escapejs }}",
        success: "{{ _('Both nodes registered successfully.')|escapejs }}",
        partial: "{{ _('One or more registrations failed.')|escapejs }}",
        aborted: "{{ _('Registration aborted.')|escapejs }}",
        visitorInfoError: "{{ _('Unable to read visitor node information.')|escapejs }}",
        hostInfoError: "{{ _('Unable to read host node information.')|escapejs }}",
        fetchAdvice: "{{ _('Make sure the visiting node is reachable. Run "./manage.py check_registration_ready" on the visiting node to verify readiness.')|escapejs }}",
    };

    function setStatus(element, message, isError) {
        if (!element) {
            return;
        }
        element.textContent = message;
        if (isError) {
            element.classList.add("errornote");
        } else {
            element.classList.remove("errornote");
        }
    }

    async function loadJson(url, options) {
        const response = await fetch(url, options);
        const text = await response.text();
        let payload;
        try {
            payload = JSON.parse(text);
        } catch (err) {
            payload = text;
        }
        if (!response.ok) {
            const detail = payload && payload.detail ? payload.detail : text || response.statusText;
            throw new Error(detail);
        }
        return payload;
    }

    function buildUrlVariants(url) {
        const variants = [];
        try {
            const parsed = new URL(url, window.location.href);
            if (parsed.protocol === "http:") {
                const secure = new URL(parsed.href);
                secure.protocol = "https:";
                variants.push(secure.href);
            }
            variants.push(parsed.href);
        } catch (err) {
            variants.push(url);
        }
        return variants.filter((value, index, self) => self.indexOf(value) === index);
    }

    async function requestWithFallback(urls, options) {
        const targets = Array.isArray(urls) ? urls : [urls];
        let lastError = null;
        for (const target of targets) {
            try {
                return await loadJson(target, options);
            } catch (error) {
                const message = error && error.message ? error.message : "";
                if (error instanceof TypeError || message === "Failed to fetch") {
                    lastError = error;
                    continue;
                }
                throw error;
            }
        }
        if (lastError) {
            throw lastError;
        }
        throw new Error("Request failed");
    }

    function formatError(error) {
        let message = "";
        if (error && typeof error.message === "string") {
            message = error.message;
        } else if (typeof error === "string") {
            message = error;
        } else if (error) {
            message = String(error);
        }
        if (message === "Failed to fetch") {
            return `${message} — ${messages.fetchAdvice}`;
        }
        return message || messages.partial;
    }

    function buildPayload(info, relation) {
        const payload = {
            hostname: info.hostname,
            address: info.address,
            port: info.port,
            mac_address: info.mac_address,
            public_key: info.public_key,
            features: info.features || [],
        };
        const relationValue = relation || info.current_relation;
        if (relationValue) {
            payload.current_relation = relationValue;
        }
        return payload;
    }

    function addSignature(payload, info) {
        if (info.token_signature) {
            payload.token = token;
            payload.signature = info.token_signature;
        }
    }

    (async function() {
        try {
            const visitorInfoTargets = buildUrlVariants(visitorInfoUrl + "?token=" + token);
            const visitorInfoPromise = requestWithFallback(visitorInfoTargets);
            const hostInfoPromise = loadJson(hostInfoUrl);
            const [visitorInfo, hostInfo] = await Promise.all([
                visitorInfoPromise,
                hostInfoPromise,
            ]);

            if (!visitorInfo || typeof visitorInfo !== "object") {
                throw new Error(messages.visitorInfoError);
            }
            if (!hostInfo || typeof hostInfo !== "object") {
                throw new Error(messages.hostInfoError);
            }

            const hostPayload = buildPayload(visitorInfo, "Downstream");
            addSignature(hostPayload, visitorInfo);
            try {
                const result = await loadJson(hostRegisterUrl, {
                    method: "POST",
                    headers: {"Content-Type": "application/json"},
                    credentials: "same-origin",
                    body: JSON.stringify(hostPayload),
                });
                if (result && result.detail) {
                    setStatus(hostResult, result.detail, false);
                } else {
                    setStatus(hostResult, messages.hostRegistered, false);
                }
            } catch (error) {
                setStatus(hostResult, formatError(error), true);
            }

            const visitorPayload = buildPayload(hostInfo, "Upstream");
            addSignature(visitorPayload, hostInfo);
            try {
                const visitorRegisterTargets = buildUrlVariants(visitorRegisterUrl);
                const result = await requestWithFallback(visitorRegisterTargets, {
                    method: "POST",
                    credentials: "include",
                    body: JSON.stringify(visitorPayload),
                });
                if (result && result.detail) {
                    setStatus(visitorResult, result.detail, false);
                } else {
                    setStatus(visitorResult, messages.visitorRegistered, false);
                }
            } catch (error) {
                setStatus(visitorResult, formatError(error), true);
            }

            if (!hostResult.classList.contains("errornote") && !visitorResult.classList.contains("errornote")) {
                setStatus(summary, messages.success, false);
            } else if (!summary.textContent) {
                setStatus(summary, messages.partial, true);
            }
        } catch (error) {
            const message = formatError(error);
            setStatus(summary, message, true);
            if (!hostResult.classList.contains("errornote")) {
                setStatus(hostResult, messages.aborted, true);
            }
            if (!visitorResult.classList.contains("errornote")) {
                setStatus(visitorResult, messages.aborted, true);
            }
        }
    })();
})();
</script>
{% endblock %}
