[
  {
    "model": "pages.usermanual",
    "fields": {
      "is_seed_data": true,
      "is_user_data": false,
      "is_deleted": false,
      "slug": "mcp-sigil-resolver",
      "title": "MCP Sigil Resolver Server",
      "description": "Architecture and integration plan for the MCP sigil resolver server.",
      "languages": "en",
      "content_html": "<h1>MCP Sigil Resolver Server \u2013 Design Proposal</h1>\n<h2>Background</h2>\n<p>Sigils are currently resolved inside the Django application through <code>core.sigil_resolver</code>, which inspects the <code>SigilRoot</code> configuration, looks up model instances, and falls back to a <code>gway</code> subprocess for unknown roots. The resolver supports nested sigils, dynamic model lookups, environment variables, and per-thread context provided through <code>core.sigil_context</code>. Sigil metadata is surfaced in the admin via the Sigil Builder view, which lists known roots and lets administrators experiment with resolution.</p>\n<p>The product roadmap calls for exposing the same capabilities outside of Django via OpenAI's Model Context Protocol (MCP) so connectors can resolve sigils over SSE.</p>\n<h2>Goals</h2>\n<ul>\n  <li>Provide an MCP-compliant server that exposes the existing resolution logic without duplicating business rules.</li>\n  <li>Enable secure remote resolution for arbitrary text with nested sigils as well as utility discovery (e.g., which roots exist).</li>\n  <li>Support opt-in per-session context (current user, current entity instances) so downstream agents can resolve contextual sigils accurately.</li>\n  <li>Keep the <code>gway</code> fallback so existing external integrations remain functional, but make it optional when MCP adoption is complete.</li>\n</ul>\n<h2>Non-Goals</h2>\n<ul>\n  <li>Replacing the in-process Django resolver.</li>\n  <li>Offering arbitrary database access beyond the existing sigil semantics.</li>\n  <li>Shipping a production-grade authentication service; the first version will rely on API keys and reverse proxies.</li>\n</ul>\n<h2>Protocol Surface</h2>\n<p>The server will expose the following MCP constructs:</p>\n<table>\n  <thead>\n    <tr>\n      <th>Type</th>\n      <th>Name</th>\n      <th>Purpose</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Tool</td>\n      <td><code>resolveSigils</code></td>\n      <td>Resolve one or more sigils inside a text payload using the current session context. Input schema: <code>{ \"text\": string, \"context\": {\"model\": {\"app_label.ModelName\": \"pk\"}}, \"options\": {\"skipUnknown\": bool}}</code>. Returns <code>{ \"resolved\": string, \"metadata\": {\"unresolved\": [string]}}</code>.</td>\n    </tr>\n    <tr>\n      <td>Tool</td>\n      <td><code>resolveSingle</code></td>\n      <td>Resolve a single sigil token and return its value or unresolved form. Thin wrapper that validates the sigil shape before delegating to <code>resolveSigils</code> for reuse.</td>\n    </tr>\n    <tr>\n      <td>Tool</td>\n      <td><code>describeSigilRoot</code></td>\n      <td>Provide metadata for a given sigil root (fields, context type) leveraging the same data that powers the Sigil Builder view.</td>\n    </tr>\n    <tr>\n      <td>Tool</td>\n      <td><code>setContext</code></td>\n      <td>Update the thread-local sigil context using <code>set_context</code> to mimic how the resolver infers instances from request state.</td>\n    </tr>\n    <tr>\n      <td>Resource</td>\n      <td><code>sigilRoots</code> (optional streaming)</td>\n      <td>Publish changes to <code>SigilRoot</code> objects so long-lived MCP sessions can react to new roots without polling. Implemented via Django signals.</td>\n    </tr>\n  </tbody>\n</table>\n<p>The server\u2019s <code>list_tools</code> handler simply advertises the tools above, while <code>call_tool</code> dispatches to a per-session service class that wraps <code>resolve_sigils</code> and <code>_resolve_token</code> logic so every invocation reuses the battle-tested paths.</p>\n<h2>Server Architecture</h2>\n<pre><code>manage.py mcp_sigil_server\n\u2514\u2500\u2500 SigilResolverServer (mcp.server.sse.SseServer)\n    \u251c\u2500\u2500 SigilSessionState (per-connection context)\n    \u2502   \u2514\u2500\u2500 SigilContextAdapter \u2194 core.sigil_context\n    \u251c\u2500\u2500 SigilResolverService\n    \u2502   \u2514\u2500\u2500 uses core.sigil_resolver.resolve_sigils\n    \u2514\u2500\u2500 SigilRootCatalog (queries SigilRoot + caches metadata)\n</code></pre>\n<ul>\n  <li><strong>Entry point</strong> \u2013 New Django management command <code>mcp_sigil_server</code> imports <code>django.setup()</code>, instantiates an <code>SseServer</code> from the <code>modelcontextprotocol</code> reference implementation, and serves it over an HTTP listener (default <code>127.0.0.1:8800</code>).</li>\n  <li><strong>Session state</strong> \u2013 On <code>accept_session</code>, capture authentication headers, initialize a <code>SigilSessionState</code>, and register a connection-specific logger so unresolved sigils continue to log warnings via <code>logger.warning</code> just like the in-process resolver.</li>\n  <li><strong>Resolver service</strong> \u2013 Wrap the existing <code>resolve_sigils</code> function. Before each call, apply any session context by temporarily invoking <code>set_context</code> / <code>clear_context</code>. After resolution, detect which tokens remained unresolved by diffing the output against the input and by checking the metadata returned from <code>_failed_resolution</code>.</li>\n  <li><strong>Sigil root catalog</strong> \u2013 Provide cached metadata for <code>describeSigilRoot</code> and resource streaming by reusing the query logic from <code>core.sigil_builder</code> (select related content type, list fields, etc.).</li>\n  <li><strong>Gway integration</strong> \u2013 Keep <code>_resolve_with_gway</code> untouched; the MCP server simply imports <code>resolve_sigils</code>, so the fallback path still shells out when no root is found.</li>\n</ul>\n<h2>Configuration &amp; Security</h2>\n<ul>\n  <li><strong>Dependencies</strong> \u2013 Add <code>modelcontextprotocol</code> (Python MCP reference SDK) to <code>requirements.txt</code> and vendor reusable schemas in a small <code>core/mcp/schemas.py</code> module to avoid duplicating JSON schema definitions across handlers.</li>\n  <li><strong>Settings</strong> \u2013 Introduce <code>settings.MCP_SIGIL_SERVER = {\"host\": \"127.0.0.1\", \"port\": 8800, \"api_key\": \"...\"}</code>. The management command reads these values and optionally the <code>--public</code> flag to bind to <code>0.0.0.0</code> behind an ingress controller.</li>\n  <li><strong>Authentication</strong> \u2013 Expect an <code>Authorization: Bearer &lt;token&gt;</code> header on <code>createSession</code>. Reject the request unless the token matches <code>settings.MCP_SIGIL_API_KEYS</code> (list) so multiple connectors can be provisioned without redeploying the service.</li>\n  <li><strong>Rate limiting</strong> \u2013 Start with a simple per-session throttle (e.g., <code>options.maxRequestsPerMinute</code>) enforced inside the session state. Upgrade to Redis-backed limits later if required.</li>\n</ul>\n<h2>Implementation Plan</h2>\n<ol>\n  <li><strong>Foundations</strong>\n    <ul>\n      <li>Add the dependency and create <code>core/mcp/__init__.py</code>, <code>core/mcp/server.py</code>, and <code>core/mcp/schemas.py</code> with Pydantic models to validate tool arguments before passing them to Django.</li>\n      <li>Implement <code>SigilResolverService</code> that exposes <code>resolve_text</code>, <code>resolve_single</code>, <code>set_context</code>, and <code>describe_root</code>. It should call <code>resolve_sigils</code> and interact with <code>SigilRoot</code> directly.</li>\n    </ul>\n  </li>\n  <li><strong>MCP server</strong>\n    <ul>\n      <li>Wire the service into an <code>SseServer</code> inside the management command. Handle lifecycle events (session start/end) to clear context using <code>clear_context</code> to prevent leaks.</li>\n      <li>Expose the tools and resources by implementing the relevant decorators from the MCP SDK.</li>\n    </ul>\n  </li>\n  <li><strong>Admin &amp; Ops</strong>\n    <ul>\n      <li>Document how to create API keys and register the connector. Provide example <code>curl</code> traces to validate the SSE handshake.</li>\n      <li>Extend deployment scripts (e.g., <code>start.sh</code> or a systemd unit) so the MCP server can run alongside Django in production.</li>\n    </ul>\n  </li>\n  <li><strong>Testing</strong>\n    <ul>\n      <li>Unit-test the service class against fixtures already used by <code>tests/test_sigil_resolution.py</code> to ensure parity with in-process resolution.</li>\n      <li>Add an async integration test that spins up the SSE server on an ephemeral port, runs through <code>list_tools</code> and <code>call_tool</code>, and verifies resolution and authorization behavior.</li>\n      <li>Reuse existing factories to assert context-aware lookups (e.g., entity sigils with <code>filter_field</code> rules).</li>\n    </ul>\n  </li>\n</ol>\n<h2>Operational Considerations</h2>\n<ul>\n  <li><strong>Observability</strong> \u2013 Emit structured JSON logs for each tool call (input length, number of tokens resolved, duration). Ship basic metrics via Prometheus or StatsD.</li>\n  <li><strong>Error handling</strong> \u2013 Map Django validation errors to MCP <code>ToolError</code> responses so clients get actionable messages. Unexpected exceptions should surface as <code>InternalError</code> while still logging stack traces.</li>\n  <li><strong>Scalability</strong> \u2013 Because the resolver relies on Django ORM calls, keep the MCP server colocated with the Django app or share the same settings module/environment to avoid mismatched configuration.</li>\n  <li><strong>Routing</strong> \u2013 When opening an extra TCP port is undesirable, set <code>MCP_SIGIL_MOUNT_PATH</code> (default <code>/mcp</code> when embedded) and let the built-in ASGI router in <code>config.asgi</code> forward <code>/mcp/sse</code> and <code>/mcp/messages/</code> into the FastMCP server. External reverse proxies such as nginx remain optional.</li>\n</ul>\n<h2>Future Enhancements</h2>\n<ul>\n  <li>Add <code>prompt</code> registrations so LLM clients can request example instructions for building sigils.</li>\n  <li>Support long-running background resolution jobs via MCP <code>jobs</code> once the reference SDK stabilizes.</li>\n  <li>Replace the <code>gway</code> fallback with a dedicated MCP tool that proxies to whatever eventually supersedes gway, allowing observability and retries over the same channel.</li>\n</ul>",
      "content_pdf": "JVBERi0xLjMKJZOMi54gUmVwb3J0TGFiIEdlbmVyYXRlZCBQREYgZG9jdW1lbnQgaHR0cDovL3d3dy5yZXBvcnRsYWIuY29tCjEgMCBvYmoKPDwKL0YxIDIgMCBSIC9GMiAzIDAgUiAvRjMgNCAwIFIgL0Y0IDUgMCBSCj4+CmVuZG9iagoyIDAgb2JqCjw8Ci9CYXNlRm9udCAvSGVsdmV0aWNhIC9FbmNvZGluZyAvV2luQW5zaUVuY29kaW5nIC9OYW1lIC9GMSAvU3VidHlwZSAvVHlwZTEgL1R5cGUgL0ZvbnQKPj4KZW5kb2JqCjMgMCBvYmoKPDwKL0Jhc2VGb250IC9IZWx2ZXRpY2EtQm9sZCAvRW5jb2RpbmcgL1dpbkFuc2lFbmNvZGluZyAvTmFtZSAvRjIgL1N1YnR5cGUgL1R5cGUxIC9UeXBlIC9Gb250Cj4+CmVuZG9iago0IDAgb2JqCjw8Ci9CYXNlRm9udCAvWmFwZkRpbmdiYXRzIC9OYW1lIC9GMyAvU3VidHlwZSAvVHlwZTEgL1R5cGUgL0ZvbnQKPj4KZW5kb2JqCjUgMCBvYmoKPDwKL0Jhc2VGb250IC9TeW1ib2wgL05hbWUgL0Y0IC9TdWJ0eXBlIC9UeXBlMSAvVHlwZSAvRm9udAo+PgplbmRvYmoKNiAwIG9iago8PAovQ29udGVudHMgMTEgMCBSIC9NZWRpYUJveCBbIDAgMCA2MTIgNzkyIF0gL1BhcmVudCAxMCAwIFIgL1Jlc291cmNlcyA8PAovRm9udCAxIDAgUiAvUHJvY1NldCBbIC9QREYgL1RleHQgL0ltYWdlQiAvSW1hZ2VDIC9JbWFnZUkgXQo+PiAvUm90YXRlIDAgL1RyYW5zIDw8Cgo+PiAKICAvVHlwZSAvUGFnZQo+PgplbmRvYmoKNyAwIG9iago8PAovQ29udGVudHMgMTIgMCBSIC9NZWRpYUJveCBbIDAgMCA2MTIgNzkyIF0gL1BhcmVudCAxMCAwIFIgL1Jlc291cmNlcyA8PAovRm9udCAxIDAgUiAvUHJvY1NldCBbIC9QREYgL1RleHQgL0ltYWdlQiAvSW1hZ2VDIC9JbWFnZUkgXQo+PiAvUm90YXRlIDAgL1RyYW5zIDw8Cgo+PiAKICAvVHlwZSAvUGFnZQo+PgplbmRvYmoKOCAwIG9iago8PAovUGFnZU1vZGUgL1VzZU5vbmUgL1BhZ2VzIDEwIDAgUiAvVHlwZSAvQ2F0YWxvZwo+PgplbmRvYmoKOSAwIG9iago8PAovQXV0aG9yIChhbm9ueW1vdXMpIC9DcmVhdGlvbkRhdGUgKEQ6MjAyNTA5MTYyMzUzNTQrMDAnMDAnKSAvQ3JlYXRvciAoUmVwb3J0TGFiIFBERiBMaWJyYXJ5IC0gd3d3LnJlcG9ydGxhYi5jb20pIC9LZXl3b3JkcyAoKSAvTW9kRGF0ZSAoRDoyMDI1MDkxNjIzNTM1NCswMCcwMCcpIC9Qcm9kdWNlciAoUmVwb3J0TGFiIFBERiBMaWJyYXJ5IC0gd3d3LnJlcG9ydGxhYi5jb20pIAogIC9TdWJqZWN0ICh1bnNwZWNpZmllZCkgL1RpdGxlICh1bnRpdGxlZCkgL1RyYXBwZWQgL0ZhbHNlCj4+CmVuZG9iagoxMCAwIG9iago8PAovQ291bnQgMiAvS2lkcyBbIDYgMCBSIDcgMCBSIF0gL1R5cGUgL1BhZ2VzCj4+CmVuZG9iagoxMSAwIG9iago8PAovRmlsdGVyIFsgL0FTQ0lJODVEZWNvZGUgL0ZsYXRlRGVjb2RlIF0gL0xlbmd0aCAyMzQyCj4+CnN0cmVhbQpHYXVITGdNUnJqJnEvKS1lQzFTNkNOVWdLJyptQUFhJiluSkRNRyJEYDtmckJXZ2YuZ1pjUU86RCs0J2hIXHVAQz4udEpZInFzQGQ5SnUtXmw7WCVob0VJUD9walpFW0lAU15OY1hSbGNkVk1BNEdKdVk0ckJRUyIvIkRZKk8zWyVpZjxcQzpxc0hWPmAvRVojblNOOWcoTVdSUlM9VyZENEZMUmFpNyJHQzA8XSlpZWs0RE5vTidqQDdvU1tJRDE2Zy1TaiNgTGVxVT51RDYrUU1RdEJdaFRJN10jPUY5WztQZGJGQD4+bVw1b2RLLCIsYjFbOUZcXEJ1R049b0knZS8wQyxxM1hVSUpQRztnNi0rZlhcJzFpMilwP19vbkgqKUFEcFw8LDJbSmlbLCVbJF9aQ2BaInM2OSU+clU9PWdiOjdkREkmS0o2SkMtdDpNaUosWGViKVA2J3RSSCcsJTE6US1jYVMkI182LSEqWDxbTmRTSFRTQWQ6VTxuOixgRE4zSGpFZmZcc1JSKC5qJDZGJSZsWDVALTUvPS4yLjpjTEEsQUw0alYvL05SaSlsRjBqZkdFbiRHJG1HTTVCVmtCcXVdYUJka1AqK05TSlBAKU8nUDwnOyJVcihONjo+ZyI2PiZIak5uUyhwVyMwdT5ZJVU4bWJKOjVPQ2xrW1VaOCJvSWJRZ2lpNTtiLzk/bVlMK3NTcSNjUGpmKkpDIVQmX2g0WC5nRDcnZklLXC9dWUtlaTR1TkAlTWJNNGcra287S1NZQiooaWJRZFVmYWhFM2gjLyElP3VaPC88czclOFBjYygmS2w4SWlJYkcyXFdRJTZsTDE8bk4wMWZ0VGBVPS4vWmttMSxDYi85aEpzR0JuQSw8cV9LN2ZdLjNdXihAUUhOUnBeczxPWXNTPiM1WWEtWFQ6TjRmUzFCOE9AKS9fSjI2XFZDK0o1WWRDZF5mOGI2MXJDJUltdXRwVj9yLGYiX11MJ1tCWS1rJlM3KWI4LTRMNWU3X2VsIyNqcTpDSkhTXGttJHVjSXJJXydbNU1PRFEvXl9cImFlRlIoKjdKUDQ1aUQ+NFhoWStVcE41UFY1JHAzczhTImxfOzloX0ZPNixJZi4hT0JyVk5HOWMqblckdU5OQWZvY2oibzpudGNlOVdiM21QaGRcRGRUQGpQbmJ0Wm9MVm9EPVE+T11OK1NLW2QoTGY8YVROYVptWF02NDlBLjVkYCk+ZHBPND1hZUk3Pj5QM1s6IkNKbTlaSW5Ka08wQjMpLGBxKj0tV0EwayYoREMpOkdDSFAlOUFBZUoqLUNvLU43UWVhNz9VRUxDZXI1JiZpYmk7JTdHNjRQMThCbDlFal4hL29jTzwjWT8lVC5ndE8nKldGSUJpak04JFZWOywzUCpUQW8xKChkTnRDL21JOWksa2BfLUFxMioqa21bSDUtQmJZVUEubjlHSE02UGIndWhgLyovbkc6cURJRFhUQUpDJmtEYFlpcWVPTWpYcS4tUFBlKiJQXSg7NSImRD1qQjdzdW5fZTAlbjFtUTZAV19bMnBOM2NeQi9VUEdTImpoY2RHaW0+IW4iXT4tYkxGRmgyK0tnO15AU04nX0FVIStnNEFQci4vLHJnYi07Tz8lPkxbZUI+Z3FzbVQhJFBVMVVhX0VqJlctTyFjcjtfOzU2Yi5BITVVISUzWmc6P1hVaWY6J0U6Sy8yXj5GXUhrVjorXiY3RmpHQzlsb1MpKioqVEMpa1kmTFQxc2YjMEI8YyYlJXBLV1FIO15IJytdSj4ick9dbkAuNlhZPU5qTENNZ0AjPVBtQ1pLVEp0O2dIJF5yIyNMTFM6aC87I3VHYi1nO0lsVW1TMUZePzVCZkJqMyEmWnA4MFUxM0RySzJLTj1eVyQ5V2pINmR1JlgrVjFjZjVIZyJGIjJTQ2BeblQ+ZSpdNEBfcS1PP2t1YEotN2tUK2VSYydYMUk4bklUSiM5RmY6VXNXXk1Ka04/VGZbJGpCXm8uRElia11PczVgOV1VLVVlYk9qP19HYkMpc3JHSW5MJ1lsLzEjN0EiU2o5QGRKcykyITVVcDwzbUBSZjlFLG9TVXI6PHBLSyYnbiVkSGknVjNMRWtUSCd1NDgnZT1RLi5pXXNuNmhgTlskKFxwRk1XckxQPDdOI05hMyYhPm4xYW1JZFVaOSdUcyt1JVEyYFUpOUJvZXBjSVVXQjQ/WHFMSjtzalQxW3A5KTEsbzNDYFstc0dEbzchZyhXbWdgTWBARUAhY28xS2pxPS4lSkAiSkhNXFVSSWAxMjVQLEA5XD05SkYybWs9bilcXGo3PGQnaFJxTXQ7bShwRT1OTlVBY1Y3TzYvSEoqPjomK1ZhRlRZTjBZQEprMzkrLmtObT1JKnBaPj4+JnFdWUYrcjlVUUxmPmxbUlA5S3NLKSEpOSxING90XT5vWFVJJT06YVlpbDI0KGdyMCJRLlJtVWE+Q1FGQUBnam9GWF9NN2NGUGZMLzAnLW9tLSJtIV05QTdRcG8lJzNJbE4hP3JnaWtNZXAzT0lCP29UIyVQKlMnZEcmVWJBW2tIX0RmcFo7UShmNTJnTGEsOEc7RG9gJTdRYFBLW2glWy8wRDBrPWlVMDxmX29kdWchOyNcOU5TcCM9N1Q7clgxQFYnOChLSGFvYzVjaFxSdFFCUWJ0dHFWbDgyTiYqTCRDKkNIP2luLWFkPydBI05daW1nZkM5R1M4NThZIyUvQWs0LmYmYzNxaWVNczhjWVd1aSwrYWojO14yZWdDZD08QzpvbFFkV0sxaHFUQE5aLWBqInJgST5tXWc/WWE7ZiRMLyVkaXBGXTxeTzQ8WFhLM3FbOmRsQzolMWZeQ1MtZF5FLzYhNShJKCo2LS4/cFFKc10iLUBTWEJvRUY+ZFomUSIjJm82Ol9yWlVIbi47cyNUdTM4PURpIVw8YDFBZ0ZVcnQ2RW5ZPz9fI2RxTzAtKmJBJlBrY2lkJWxjL19lUz9iXDFKLlZqSXNLLl84WT5ULEBAWzgoMUsmQDkrKU1ZZiNrMyopI0NkbC05WUVDUGsuMSVNIWROJSU+bmw7Jk4pQGo3RydULCU9NDpeUk1JLTYncVVkQi1+PmVuZHN0cmVhbQplbmRvYmoKMTIgMCBvYmoKPDwKL0ZpbHRlciBbIC9BU0NJSTg1RGVjb2RlIC9GbGF0ZURlY29kZSBdIC9MZW5ndGggNTk0Cj4+CnN0cmVhbQpHYXNKTzk1aVE9Jjs5TkonbHRrW1UzOCJETlIpPEpULE9MckZOZTtqZElLPTQuSWM8Ol5bST1YKlZZKyNKZz9IMyk9QkdaLlhbRFsuU25Scz9RMzYmLm9cQnAyNipfMSdxMCZDMWAlb1NTV3UsM0JmTjpOcylPWkNNUWVTSWNhLFk/LVQ+bmcoQFVgSCI/YjwvMj0/dSxdc1xOKkc8NjwkL0RDWFhDKzE6WzY2RHFmPS91U2ROaG5FWGNVLyxJcExxIUs1JSloJiZAOD4xaDZcYnNqXUtIO1VbQzY1RUo4RXBtQVxQVkFRRzVLQXFiOCdFLzdISFBMaXEuK1hYRE1TRl8wPlhGR2twNDpIUS4sX0s8NiIxUEpvbjVLKXVuOnQjaklSYm5IKjA0VTFNZEcqR2QzazNHRC4tWy4xQTxoVTxiSSdubiIlS2deNm9ZdTRVcCYraUhFL2dcS2k6WWd1IVFOai4kdVVfRD1fcUIyaydCN0hUcSsqZzklSmtiPzosQyhFKUZHKnJiXz5JJ2dDYGpCZTxjI01xcldmOGhkblpCPnAsUS5SPj5HYilOS2JZI21vMW85ODAmWDovY2NeNEtfPD9ZJis8PSpXQSdlPGM+MllGY0ZIdExDYyImbkpSRDZNUV4pQi8yQDtuQ0dgMyE3JyMrOUpyUDpdOiJKb1czJy8wZms4ISUyVWoxVTJVRW9IMCpTRVsiKClFY0JqK05gX0siLm9KJVFGNTI8LGFMOC91OGtzWS9UZj0jPDc7I0BqbmVeOUUjR151LShCfj5lbmRzdHJlYW0KZW5kb2JqCnhyZWYKMCAxMwowMDAwMDAwMDAwIDY1NTM1IGYgCjAwMDAwMDAwNzMgMDAwMDAgbiAKMDAwMDAwMDEzNCAwMDAwMCBuIAowMDAwMDAwMjQxIDAwMDAwIG4gCjAwMDAwMDAzNTMgMDAwMDAgbiAKMDAwMDAwMDQzNiAwMDAwMCBuIAowMDAwMDAwNTEzIDAwMDAwIG4gCjAwMDAwMDA3MDggMDAwMDAgbiAKMDAwMDAwMDkwMyAwMDAwMCBuIAowMDAwMDAwOTcyIDAwMDAwIG4gCjAwMDAwMDEyNjggMDAwMDAgbiAKMDAwMDAwMTMzNCAwMDAwMCBuIAowMDAwMDAzNzY4IDAwMDAwIG4gCnRyYWlsZXIKPDwKL0lEIApbPDQ1Nzk2MzIyNjc1NGRiNGIwNGRjOTNkZmMzMjkzM2I2Pjw0NTc5NjMyMjY3NTRkYjRiMDRkYzkzZGZjMzI5MzNiNj5dCiUgUmVwb3J0TGFiIGdlbmVyYXRlZCBQREYgZG9jdW1lbnQgLS0gZGlnZXN0IChodHRwOi8vd3d3LnJlcG9ydGxhYi5jb20pCgovSW5mbyA5IDAgUgovUm9vdCA4IDAgUgovU2l6ZSAxMwo+PgpzdGFydHhyZWYKNDQ1MwolJUVPRgo="
    }
  }
]