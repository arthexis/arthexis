name: Resolve Previous Review Threads

on:
  issue_comment:
    types:
      - created

permissions:
  contents: read
  pull-requests: write

jobs:
  resolve-older-threads:
    if: ${{ github.event.issue.pull_request }}
    runs-on: ubuntu-latest
    steps:
      - name: Resolve unresolved review threads older than trigger comment
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            /**
             * Resolve unresolved pull request review threads whose latest comment
             * predates the trigger issue comment timestamp.
             */
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issueNumber = context.payload.issue.number;
            const triggerTimestamp = context.payload.comment.created_at;
            const triggerCommentUrl = context.payload.comment.html_url;
            const triggerCommentBody = context.payload.comment.body;
            const triggerCommentAuthor = context.payload.comment.user?.login;
            const triggerAppSlug = context.payload.comment?.performed_via_github_app?.slug;
            const normalizedCommentBody = (triggerCommentBody || '').trim();

            /**
             * Determine whether the triggering comment text is one of the expected
             * "view task" variants posted by Codex-related integrations.
             */
            const isExpectedTriggerComment = (body) => {
              const allowedBodies = new Set([
                'View task â†’',
                'View task ->',
                'View task',
              ]);
              return allowedBodies.has(body);
            };

            /**
             * Determine whether the comment was posted by a trusted Codex actor.
             */
            const isTrustedTriggerAuthor = (author, appSlug) => {
              const allowedAuthors = new Set([
                'chatgpt-codex-connector[bot]',
              ]);
              const allowedAppSlugs = new Set([
                'chatgpt-codex-connector',
              ]);
              return allowedAuthors.has(author || '') || allowedAppSlugs.has(appSlug || '');
            };

            const shouldProcessComment =
              isExpectedTriggerComment(normalizedCommentBody)
              && isTrustedTriggerAuthor(triggerCommentAuthor, triggerAppSlug);

            if (!shouldProcessComment) {
              core.info(
                `Skipping comment: body="${normalizedCommentBody}" author="${triggerCommentAuthor || 'unknown'}" app="${triggerAppSlug || 'unknown'}".`,
              );
              return;
            }

            core.info(`Matched trigger comment from "${triggerCommentAuthor || 'unknown'}" using app "${triggerAppSlug || 'unknown'}".`);

            if (!triggerTimestamp) {
              throw new Error('Missing issue comment timestamp in payload.');
            }

            if (!triggerCommentUrl) {
              throw new Error('Missing issue comment URL in payload.');
            }

            const { data: prData } = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: issueNumber,
            });

            const triggerDate = new Date(triggerTimestamp);
            if (Number.isNaN(triggerDate.getTime())) {
              throw new TypeError(`Invalid trigger timestamp: ${triggerTimestamp}`);
            }

            const reviewThreads = [];
            let cursor = null;
            let hasNextPage = true;

            while (hasNextPage) {
              const response = await github.graphql(
                `query($owner: String!, $repo: String!, $pullNumber: Int!, $cursor: String) {
                   repository(owner: $owner, name: $repo) {
                     pullRequest(number: $pullNumber) {
                       reviewThreads(first: 100, after: $cursor) {
                         nodes {
                           id
                           isResolved
                           comments(last: 1) {
                             nodes {
                               createdAt
                             }
                           }
                         }
                         pageInfo {
                           hasNextPage
                           endCursor
                         }
                       }
                     }
                   }
                 }`,
                {
                  owner,
                  repo,
                  pullNumber: prData.number,
                  cursor,
                },
              );

              const threads = response.repository.pullRequest.reviewThreads;
              reviewThreads.push(...threads.nodes);
              hasNextPage = threads.pageInfo.hasNextPage;
              cursor = threads.pageInfo.endCursor;
            }

            const getLatestTimestamp = (thread) => {
              const commentTimestamps = (thread.comments?.nodes || [])
                .map((comment) => comment.createdAt)
                .filter(Boolean)
                .map((value) => new Date(value))
                .filter((date) => !Number.isNaN(date.getTime()));

              if (commentTimestamps.length === 0) {
                return null;
              }

              return new Date(Math.max(...commentTimestamps.map((date) => date.getTime())));
            };

            const threadsToResolve = reviewThreads.filter((thread) => {
              if (thread.isResolved) {
                return false;
              }
              const latestTimestamp = getLatestTimestamp(thread);
              return latestTimestamp !== null && latestTimestamp < triggerDate;
            });

            core.info(`Found ${threadsToResolve.length} unresolved review thread(s) older than ${triggerTimestamp}.`);

            let resolvedCount = 0;
            const failedThreads = [];

            for (const thread of threadsToResolve) {
              try {
                await github.graphql(
                  `mutation($threadId: ID!) {
                     resolveReviewThread(input: {threadId: $threadId}) {
                       thread {
                         id
                         isResolved
                       }
                     }
                   }`,
                  { threadId: thread.id },
                );
                resolvedCount += 1;
              } catch (error) {
                const message = error instanceof Error ? error.message : String(error);
                failedThreads.push(thread.id);
                core.warning(`Failed to resolve thread ${thread.id}: ${message}`);
              }
            }

            if (failedThreads.length > 0) {
              core.warning(`Failed thread IDs: ${failedThreads.join(', ')}`);
            }

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: issueNumber,
              body: `Resolved by [trigger comment](${triggerCommentUrl}).`,
            });

            core.info(`Resolved ${resolvedCount} of ${threadsToResolve.length} thread(s).`);
