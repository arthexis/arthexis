name: Resolve Previous Review Threads

on:
  issue_comment:
    types:
      - created

permissions:
  contents: read
  pull-requests: write

jobs:
  resolve-older-threads:
    if: ${{ github.event.issue.pull_request && github.event.comment.body == 'View task â†’' && github.event.comment.user.login == 'chatgpt-codex-connector[bot]' }}
    runs-on: ubuntu-latest
    steps:
      - name: Resolve unresolved review threads older than trigger comment
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            /**
             * Resolve unresolved pull request review threads whose latest comment
             * predates the trigger issue comment timestamp.
             */
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issueNumber = context.payload.issue.number;
            const triggerTimestamp = context.payload.comment.created_at;
            const triggerCommentUrl = context.payload.comment.html_url;
            const triggerAppSlug = context.payload.comment?.performed_via_github_app?.slug;

            if (triggerAppSlug !== 'chatgpt-codex-connector') {
              core.info(`Skipping: triggering comment app was "${triggerAppSlug || 'unknown'}", expected "chatgpt-codex-connector".`);
              return;
            }

            if (!triggerTimestamp) {
              throw new Error('Missing issue comment timestamp in payload.');
            }

            if (!triggerCommentUrl) {
              throw new Error('Missing issue comment URL in payload.');
            }

            const { data: prData } = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: issueNumber,
            });

            const triggerDate = new Date(triggerTimestamp);
            if (Number.isNaN(triggerDate.getTime())) {
              throw new TypeError(`Invalid trigger timestamp: ${triggerTimestamp}`);
            }

            const reviewThreads = [];
            let cursor = null;
            let hasNextPage = true;

            while (hasNextPage) {
              const response = await github.graphql(
                `query($owner: String!, $repo: String!, $pullNumber: Int!, $cursor: String) {
                   repository(owner: $owner, name: $repo) {
                     pullRequest(number: $pullNumber) {
                       reviewThreads(first: 100, after: $cursor) {
                         nodes {
                           id
                           isResolved
                           comments(last: 1) {
                             nodes {
                               createdAt
                             }
                           }
                         }
                         pageInfo {
                           hasNextPage
                           endCursor
                         }
                       }
                     }
                   }
                 }`,
                {
                  owner,
                  repo,
                  pullNumber: prData.number,
                  cursor,
                },
              );

              const threads = response.repository.pullRequest.reviewThreads;
              reviewThreads.push(...threads.nodes);
              hasNextPage = threads.pageInfo.hasNextPage;
              cursor = threads.pageInfo.endCursor;
            }

            const getLatestTimestamp = (thread) => {
              const commentTimestamps = (thread.comments?.nodes || [])
                .map((comment) => comment.createdAt)
                .filter(Boolean)
                .map((value) => new Date(value))
                .filter((date) => !Number.isNaN(date.getTime()));

              if (commentTimestamps.length === 0) {
                return null;
              }

              return new Date(Math.max(...commentTimestamps.map((date) => date.getTime())));
            };

            const threadsToResolve = reviewThreads.filter((thread) => {
              if (thread.isResolved) {
                return false;
              }
              const latestTimestamp = getLatestTimestamp(thread);
              return latestTimestamp !== null && latestTimestamp < triggerDate;
            });

            core.info(`Found ${threadsToResolve.length} unresolved review thread(s) older than ${triggerTimestamp}.`);

            let resolvedCount = 0;
            const failedThreads = [];

            for (const thread of threadsToResolve) {
              try {
                await github.graphql(
                  `mutation($threadId: ID!) {
                     resolveReviewThread(input: {threadId: $threadId}) {
                       thread {
                         id
                         isResolved
                       }
                     }
                   }`,
                  { threadId: thread.id },
                );
                resolvedCount += 1;
              } catch (error) {
                const message = error instanceof Error ? error.message : String(error);
                failedThreads.push(thread.id);
                core.warning(`Failed to resolve thread ${thread.id}: ${message}`);
              }
            }

            if (failedThreads.length > 0) {
              core.warning(`Failed thread IDs: ${failedThreads.join(', ')}`);
            }

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: issueNumber,
              body: `Resolved by [trigger comment](${triggerCommentUrl}).`,
            });

            core.info(`Resolved ${resolvedCount} of ${threadsToResolve.length} thread(s).`);
