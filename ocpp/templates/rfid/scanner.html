{% with prefix=prefix|default:"rfid" %}
  <div id="{{ prefix }}-scanner">
    {% if toggle_url or admin_view_url or public_view_url %}
      <div class="rfid-mode-toggle">
        {% if toggle_url %}
          <a id="{{ prefix }}-mode-toggle" class="button" href="{{ toggle_url }}" data-toggle-url="{{ toggle_url }}">{{ toggle_label }}</a>
        {% endif %}
        {% if request.user.is_staff and admin_view_url %}
          <a class="button secondary" href="{{ admin_view_url }}">Admin View</a>
        {% elif request.user.is_staff and public_view_url %}
          <a class="button secondary" href="{{ public_view_url }}">Public View</a>
        {% endif %}
      </div>
    {% endif %}
  <p id="{{ prefix }}-status">Scanner ready</p>
  <p>
    {% if request.user.is_staff %}
      <button id="{{ prefix }}-connect-local">Connect Local Scanner</button>
      <button id="{{ prefix }}-deep-read">Enable Deep Read</button>
      <a id="{{ prefix }}-configure" href="#" style="display:none; margin-left:1em;"></a>
    {% endif %}
  </p>
  {% if table_mode %}
    <div class="rfid-table-mode">
      <table class="rfid-history" id="{{ prefix }}-history">
        <thead>
          <tr>
            <th>Time</th>
            <th>Label</th>
            <th>Type</th>
            <th>Color</th>
            <th>Valid</th>
            {% if request.user.is_staff %}
              <th>RFID</th>
            {% endif %}
            {% if show_release_info %}
              <th>Released</th>
              <th>Reference</th>
            {% endif %}
          </tr>
        </thead>
        <tbody id="{{ prefix }}-history-body"></tbody>
      </table>
      <p class="rfid-history-total">Total scanned: <span id="{{ prefix }}-total-count">0</span></p>
    </div>
  {% else %}
    <div class="field"><span class="label">Label:</span><span class="value" id="{{ prefix }}-label"></span></div>
    <div class="field"><span class="label">Type:</span><span class="value" id="{{ prefix }}-kind"></span></div>
    <div class="field"><span class="label">Color:</span><span class="value" id="{{ prefix }}-color"></span></div>
    <div class="field"><span class="label">Valid:</span><span class="value" id="{{ prefix }}-allowed"></span></div>
    {% if request.user.is_staff %}
      <div class="field"><span class="label">RFID:</span><span class="value" id="{{ prefix }}-rfid"></span></div>
    {% endif %}
    {% if show_release_info %}
      <div class="field"><span class="label">Released:</span><span class="value" id="{{ prefix }}-released"></span></div>
      <div class="field"><span class="label">Reference:</span><span class="value" id="{{ prefix }}-reference"></span></div>
    {% endif %}
    {% if request.user.is_staff %}
      <div id="{{ prefix }}-deep-details" class="deep-read-details" style="display:none;">
        <h3>Deep Read Details</h3>
        <div class="deep-read-keys">
          <div class="deep-read-key">
            <span class="label">Key A:</span>
            <span class="value" id="{{ prefix }}-key-a"></span>
          </div>
          <div class="deep-read-key">
            <span class="label">Key B:</span>
            <span class="value" id="{{ prefix }}-key-b"></span>
          </div>
        </div>
        <p class="deep-read-summary" id="{{ prefix }}-deep-status"></p>
        <ul id="{{ prefix }}-deep-blocks" class="deep-read-blocks"></ul>
      </div>
    {% endif %}
  {% endif %}
</div>
<style>
#{{ prefix }}-scanner {
  --rfid-table-border: #d0d5dd;
  --rfid-header-bg: #f1f5f9;
  --rfid-header-text: #1f2937;
  --rfid-row-bg: #ffffff;
  --rfid-row-alt-bg: #f8fafc;
  --rfid-row-text: #111827;
  --rfid-row-hover-bg: #e0f2fe;
}

@media (prefers-color-scheme: dark) {
  #{{ prefix }}-scanner {
    --rfid-table-border: rgba(255, 255, 255, 0.24);
    --rfid-header-bg: rgba(255, 255, 255, 0.08);
    --rfid-header-text: #f9fafb;
    --rfid-row-bg: rgba(17, 24, 39, 0.7);
    --rfid-row-alt-bg: rgba(17, 24, 39, 0.55);
    --rfid-row-text: #e5e7eb;
    --rfid-row-hover-bg: rgba(59, 130, 246, 0.3);
  }
}

#{{ prefix }}-scanner .rfid-mode-toggle {
  display: flex;
  justify-content: flex-end;
  flex-wrap: wrap;
  gap: 0.75em;
  margin-bottom: 1em;
}

#{{ prefix }}-scanner .rfid-mode-toggle .button {
  text-decoration: none;
  padding: 0.35em 0.9em;
  border-radius: 9999px;
  font-weight: 600;
  background: var(--rfid-header-bg);
  color: var(--rfid-header-text);
  border: 1px solid var(--rfid-table-border);
  transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out, border-color 0.2s ease-in-out;
}

#{{ prefix }}-scanner .rfid-mode-toggle .button:hover {
  background: var(--rfid-row-hover-bg);
}

#{{ prefix }}-scanner .rfid-mode-toggle .button.secondary {
  background: transparent;
  color: inherit;
}

#{{ prefix }}-scanner .rfid-mode-toggle .button.secondary:hover {
  background: var(--rfid-header-bg);
}

#{{ prefix }}-scanner .field {
  display: flex;
  margin: 0.5em 0;
  font-size: 1.2em;
}
#{{ prefix }}-scanner .label {
  width: 7em;
  font-weight: bold;
}
#{{ prefix }}-scanner .value {
  flex: 1;
}
#{{ prefix }}-scanner .rfid-table-mode {
  margin-top: 1em;
}
#{{ prefix }}-scanner .rfid-history {
  border-collapse: separate;
  border-spacing: 0;
  width: 100%;
  border: 1px solid var(--rfid-table-border);
  border-radius: 0.5rem;
  overflow: hidden;
  background-color: var(--rfid-row-bg);
  color: var(--rfid-row-text);
}
#{{ prefix }}-scanner .rfid-history th,
#{{ prefix }}-scanner .rfid-history td {
  padding: 0.5em 0.75em;
  text-align: left;
  border-right: 1px solid var(--rfid-table-border);
}
#{{ prefix }}-scanner .rfid-history th:last-child,
#{{ prefix }}-scanner .rfid-history td:last-child {
  border-right: none;
}
#{{ prefix }}-scanner .rfid-history thead th {
  background-color: var(--rfid-header-bg);
  color: var(--rfid-header-text);
  font-weight: 600;
  border-bottom: 1px solid var(--rfid-table-border);
}
#{{ prefix }}-scanner .rfid-history tbody tr {
  background-color: var(--rfid-row-bg);
  transition: background-color 0.2s ease-in-out;
}
#{{ prefix }}-scanner .rfid-history tbody tr:nth-child(odd) {
  background-color: var(--rfid-row-alt-bg);
}
#{{ prefix }}-scanner .rfid-history tbody tr:hover {
  background-color: var(--rfid-row-hover-bg);
}
#{{ prefix }}-scanner .rfid-history-total {
  font-weight: bold;
  margin-top: 0.75em;
  color: var(--rfid-row-text);
}
#{{ prefix }}-scanner .deep-read-details {
  margin-top: 1.5em;
  padding: 1em 1.25em;
  border: 1px solid var(--rfid-table-border);
  border-radius: 0.5rem;
  background-color: var(--rfid-row-alt-bg);
  color: var(--rfid-row-text);
}
#{{ prefix }}-scanner .deep-read-details h3 {
  margin: 0 0 0.75em;
  font-size: 1.1em;
}
#{{ prefix }}-scanner .deep-read-keys {
  display: flex;
  flex-wrap: wrap;
  gap: 0.75em;
  margin: 0 0 0.75em;
}
#{{ prefix }}-scanner .deep-read-key {
  display: flex;
  gap: 0.5em;
  align-items: baseline;
}
#{{ prefix }}-scanner .deep-read-key .label {
  width: auto;
  font-weight: 600;
}
#{{ prefix }}-scanner .deep-read-key .value {
  font-family: "SFMono-Regular", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 0.95em;
}
#{{ prefix }}-scanner .deep-read-summary {
  margin: 0 0 0.75em;
  font-size: 0.95em;
}
#{{ prefix }}-scanner .deep-read-blocks {
  margin: 0;
  padding-left: 1.25em;
  list-style: disc;
  font-family: "SFMono-Regular", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 0.9em;
}
#{{ prefix }}-scanner .deep-read-blocks li {
  margin-bottom: 0.35em;
}
#{{ prefix }}-scanner .deep-read-blocks li:last-child {
  margin-bottom: 0;
}
#{{ prefix }}-status {
  font-size: 1.2em;
  margin-bottom: 1em;
}
</style>
<script>
(function(){
  const statusEl = document.getElementById('{{ prefix }}-status');
  const labelEl = document.getElementById('{{ prefix }}-label');
  const kindEl = document.getElementById('{{ prefix }}-kind');
  const colorEl = document.getElementById('{{ prefix }}-color');
  const allowedEl = document.getElementById('{{ prefix }}-allowed');
  const rfidEl = document.getElementById('{{ prefix }}-rfid');
  const releasedEl = document.getElementById('{{ prefix }}-released');
  const referenceEl = document.getElementById('{{ prefix }}-reference');
  const connectBtn = document.getElementById('{{ prefix }}-connect-local');
  const deepBtn = document.getElementById('{{ prefix }}-deep-read');
  const configureEl = document.getElementById('{{ prefix }}-configure');
  const modeToggleBtn = document.getElementById('{{ prefix }}-mode-toggle');
  const deepDetailsEl = document.getElementById('{{ prefix }}-deep-details');
  const keyAEl = document.getElementById('{{ prefix }}-key-a');
  const keyBEl = document.getElementById('{{ prefix }}-key-b');
  const deepBlocksEl = document.getElementById('{{ prefix }}-deep-blocks');
  const deepStatusEl = document.getElementById('{{ prefix }}-deep-status');
  const adminTemplate = '{{ admin_change_url_template|default:""|escapejs }}';
  const tableMode = {% if table_mode %}true{% else %}false{% endif %};

  const historyBody = tableMode ? document.getElementById('{{ prefix }}-history-body') : null;
  const totalCountEl = tableMode ? document.getElementById('{{ prefix }}-total-count') : null;
  const isStaff = {{ request.user.is_staff|yesno:"true,false" }};
  const showReleaseInfo = {{ show_release_info|yesno:"true,false" }};

  let historyCount = 0;
  let localPort = null;
  let localReader = null;
  let localConnected = false;
  let lastLocalValue = null;
  let lastLocalAt = 0;
  const historyEntries = tableMode ? new Map() : null;
  let deepReadActive = false;

  if(modeToggleBtn){
    const toggleTarget = modeToggleBtn.getAttribute('data-toggle-url') || modeToggleBtn.getAttribute('href');
    if(toggleTarget){
      modeToggleBtn.addEventListener('click', function(event){
        event.preventDefault();
        window.location.href = toggleTarget;
      });
    }
  }

  function booleanText(value){
    if(value === undefined || value === null){
      return '';
    }
    return value ? 'Yes' : 'No';
  }

  function normalizeKeyValue(value){
    if(typeof value === 'string'){
      return value.trim().toUpperCase();
    }
    if(value === undefined || value === null){
      return '';
    }
    return String(value);
  }

  function formatKeyText(value, verified){
    const normalized = normalizeKeyValue(value);
    if(!normalized){
      return '';
    }
    if(verified === undefined || verified === null){
      return normalized;
    }
    return verified ? `${normalized} (verified)` : `${normalized} (unverified)`;
  }

  function formatBlockEntry(entry){
    if(!entry || typeof entry !== 'object'){
      return null;
    }
    const parts = [];
    if(typeof entry.block === 'number' && Number.isFinite(entry.block)){
      parts.push(`Block ${entry.block}`);
    }
    if(entry.key){
      parts.push(`Key ${entry.key}`);
    }
    let dataText = '';
    if(Array.isArray(entry.data)){
      dataText = entry.data
        .map((value) => {
          const number = Number(value);
          if(Number.isFinite(number)){
            return number.toString(16).padStart(2, '0').toUpperCase();
          }
          if(typeof value === 'string' && value){
            return value.toUpperCase();
          }
          return '';
        })
        .filter(Boolean)
        .join(' ');
    } else if(entry.data !== undefined && entry.data !== null){
      dataText = String(entry.data);
    }
    if(dataText){
      parts.push(dataText);
    }
    if(!parts.length){
      return null;
    }
    return parts.join(' â€“ ');
  }

  function clearDeepDetails(){
    if(!deepDetailsEl){
      return;
    }
    deepDetailsEl.style.display = 'none';
    if(keyAEl){ keyAEl.textContent = ''; }
    if(keyBEl){ keyBEl.textContent = ''; }
    if(deepStatusEl){ deepStatusEl.textContent = ''; }
    if(deepBlocksEl){ deepBlocksEl.innerHTML = ''; }
  }

  function setDeepReadState(enabled, options){
    const opts = Object.assign({updateStatus: true, clearDetails: true}, options || {});
    deepReadActive = Boolean(enabled);
    if(deepBtn){
      deepBtn.textContent = deepReadActive ? 'Disable Deep Read' : 'Enable Deep Read';
      deepBtn.setAttribute('aria-pressed', deepReadActive ? 'true' : 'false');
    }
    if(opts.updateStatus){
      statusEl.textContent = deepReadActive ? 'Deep read enabled' : 'Deep read disabled';
    }
    if(!deepReadActive && opts.clearDetails){
      clearDeepDetails();
    }
  }

  function updateDeepDetails(data){
    if(!deepDetailsEl || tableMode){
      return;
    }
    const dumpEntries = Array.isArray(data && data.dump) ? data.dump : [];
    const hasDump = dumpEntries.length > 0;
    const isDeep = Boolean(data && data.deep_read);
    if(!isDeep && !hasDump){
      clearDeepDetails();
      return;
    }
    if(isDeep){
      setDeepReadState(true, {updateStatus: false, clearDetails: false});
    }
    deepDetailsEl.style.display = 'block';
    const keys = (data && data.keys) || {};
    if(keyAEl){
      const keyAValue = keys.a !== undefined ? keys.a : keys.key_a;
      const keyAVerified =
        keys.a_verified !== undefined ? keys.a_verified : keys.key_a_verified;
      keyAEl.textContent = formatKeyText(keyAValue, keyAVerified);
    }
    if(keyBEl){
      const keyBValue = keys.b !== undefined ? keys.b : keys.key_b;
      const keyBVerified =
        keys.b_verified !== undefined ? keys.b_verified : keys.key_b_verified;
      keyBEl.textContent = formatKeyText(keyBValue, keyBVerified);
    }
    if(deepBlocksEl){
      deepBlocksEl.innerHTML = '';
      dumpEntries.forEach((entry) => {
        const text = formatBlockEntry(entry);
        if(text){
          const item = document.createElement('li');
          item.textContent = text;
          deepBlocksEl.appendChild(item);
        }
      });
      if(!deepBlocksEl.childElementCount){
        const item = document.createElement('li');
        item.textContent = 'No readable data blocks.';
        deepBlocksEl.appendChild(item);
      }
    }
    if(deepStatusEl){
      if(hasDump){
        const count = dumpEntries.length;
        deepStatusEl.textContent = `Discovered ${count} data block${count === 1 ? '' : 's'}.`;
      } else {
        deepStatusEl.textContent = 'No data blocks were readable with the current keys.';
      }
    }
  }

  function validText(data){
    if(data.allowed === undefined || data.allowed === null){
      return '';
    }
    return data.allowed && data.released ? 'Yes' : 'No';
  }

  function buildHistoryCells(data, labelValue){
    const values = [
      new Date().toLocaleTimeString(),
      labelValue,
      data.kind || '',
      data.color || '',
      validText(data),
    ];
    if(isStaff){
      values.push(data.rfid || '');
    }
    if(showReleaseInfo){
      values.push(booleanText(data.released));
      values.push(data.reference || '');
    }
    return values;
  }

  function appendHistoryRow(data, labelValue){
    if(!historyBody){
      return;
    }
    const key = data.rfid || (labelValue ? `label:${labelValue}` : null);
    if(!key){
      return;
    }
    if(historyEntries && historyEntries.has(key)){
      const existingRow = historyEntries.get(key);
      if(existingRow && existingRow.parentElement === historyBody){
        historyBody.removeChild(existingRow);
      }
    }
    const row = document.createElement('tr');
    buildHistoryCells(data, labelValue).forEach((value) => {
      const cell = document.createElement('td');
      cell.textContent = value;
      row.appendChild(cell);
    });
    historyBody.insertBefore(row, historyBody.firstChild);
    if(historyEntries){
      historyEntries.set(key, row);
      historyCount = historyEntries.size;
    } else {
      historyCount += 1;
    }
    if(totalCountEl){
      totalCountEl.textContent = String(historyCount);
    }
  }

  function showError(message){
    console.error(message);
    const defaultMsg = 'RFID reader not detected. Please connect the reader.';
    clearDeepDetails();
    if(typeof message === 'string' && message){
      statusEl.textContent = message;
    } else {
      statusEl.textContent = defaultMsg;
    }
  }

  function updateFromData(data){
    if(!data || data.error){
      if(data && data.error){
        showError(data.error);
      }
      return;
    }
    if(!data.rfid){
      clearDeepDetails();
      return;
    }
    const labelValue = data.label_id === undefined || data.label_id === null ? '' : data.label_id;
    if(labelEl){ labelEl.textContent = labelValue; }
    if(kindEl){ kindEl.textContent = data.kind || ''; }
    if(rfidEl){ rfidEl.textContent = data.rfid || ''; }
    if(colorEl){ colorEl.textContent = data.color || ''; }
    if(allowedEl){ allowedEl.textContent = validText(data); }
    if(releasedEl){ releasedEl.textContent = booleanText(data.released); }
    if(referenceEl){ referenceEl.textContent = data.reference || ''; }
    const hasReferenceLink = data.reference && /^https?:\/\//i.test(data.reference);
    if(referenceEl && hasReferenceLink){
      const w = window.open(data.reference, '_blank');
      if(w){ w.focus(); }
    } else if(!referenceEl && tableMode && showReleaseInfo && hasReferenceLink){
      const w = window.open(data.reference, '_blank');
      if(w){ w.focus(); }
    }
    if(configureEl){
      configureEl.textContent = `Configure RFID ${labelValue}`;
      configureEl.href = adminTemplate ? adminTemplate.replace('0', labelValue) : '#';
      configureEl.style.display = 'inline';
    }
    updateDeepDetails(data);
    if(deepBtn && data.deep_read){
      setDeepReadState(true, {updateStatus: false, clearDetails: false});
    }
    const okText = data.allowed === undefined ? '' : (data.allowed ? 'OK' : 'BAD');
    const statusMsg = okText ? `RFID ${labelValue} ${okText}` : `RFID ${labelValue}`;
    statusEl.textContent = data.created ? `Created ${statusMsg}` : statusMsg;
    if(tableMode){
      appendHistoryRow(data, labelValue);
    }
  }

  async function poll(){
    try {
      const resp = await fetch('{{ scan_url }}');
      const data = await resp.json();
      if(data.error){
        showError(data.error);
      } else {
        updateFromData(data);
      }
    } catch(err){
      showError(err);
    } finally {
      setTimeout(poll, 200);
    }
  }

  function getCookie(name){
    const cookies = document.cookie ? document.cookie.split('; ') : [];
    for(let i = 0; i < cookies.length; i += 1){
      const parts = cookies[i].split('=');
      const key = parts.shift();
      if(key === name){
        return decodeURIComponent(parts.join('='));
      }
    }
    return null;
  }

  async function sendLocalScan(rfidValue){
    const headers = {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
    };
    const csrf = getCookie('csrftoken');
    if(csrf){
      headers['X-CSRFToken'] = csrf;
    }
    try {
      const resp = await fetch('{{ scan_url }}', {
        method: 'POST',
        credentials: 'same-origin',
        headers,
        body: JSON.stringify({rfid: rfidValue})
      });
      const data = await resp.json();
      if(!resp.ok || data.error){
        showError(data.error || 'Unable to validate RFID');
        return;
      }
      updateFromData(data);
    } catch(err){
      showError('Local scanner validation failed');
    }
  }

  function handleLocalScan(rawValue){
    if(!rawValue){
      return;
    }
    const cleaned = rawValue.replace(/[^0-9A-Fa-f]/g, '').toUpperCase();
    if(!cleaned){
      return;
    }
    const now = Date.now();
    if(lastLocalValue === cleaned && now - lastLocalAt < 300){
      return;
    }
    lastLocalValue = cleaned;
    lastLocalAt = now;
    sendLocalScan(cleaned);
  }

  async function readFromLocalPort(){
    if(!localPort || !localPort.readable){
      throw new Error('Local scanner is not readable');
    }
    localReader = localPort.readable.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    try {
      while(true){
        const {value, done} = await localReader.read();
        if(done){
          break;
        }
        if(value){
          buffer += decoder.decode(value, {stream: true});
          const parts = buffer.split(/[\r\n]+/);
          buffer = parts.pop() || '';
          for(let i = 0; i < parts.length; i += 1){
            handleLocalScan(parts[i].trim());
          }
        }
      }
      buffer += decoder.decode();
      if(buffer.trim()){
        handleLocalScan(buffer.trim());
      }
    } finally {
      if(localReader){
        try { localReader.releaseLock(); } catch(err) { /* ignore */ }
        localReader = null;
      }
    }
  }

  async function connectLocalScanner(){
    if(!('serial' in navigator)){
      showError('This browser does not support connecting to local scanners.');
      return;
    }
    try {
      statusEl.textContent = 'Select a local scanner to connect.';
      const port = await navigator.serial.requestPort();
      await port.open({baudRate: 9600});
      localPort = port;
      localConnected = true;
      if(connectBtn){
        connectBtn.disabled = true;
        connectBtn.textContent = 'Scanner Connected';
      }
      statusEl.textContent = 'Local scanner connected. Awaiting RFID...';
      await readFromLocalPort();
    } catch(err){
      if(err && err.name === 'NotFoundError'){
        statusEl.textContent = 'Scanner ready';
      } else if(localConnected){
        showError('Local scanner disconnected');
      } else {
        showError('Failed to connect to local scanner');
      }
    } finally {
      if(localReader){
        try { await localReader.cancel(); } catch(err) { /* ignore */ }
      }
      if(localPort){
        try { await localPort.close(); } catch(err) { /* ignore */ }
        localPort = null;
      }
      if(connectBtn){
        connectBtn.disabled = false;
        connectBtn.textContent = 'Connect Local Scanner';
      }
      if(localConnected){
        statusEl.textContent = 'Local scanner disconnected';
      }
      localConnected = false;
      localReader = null;
    }
  }

  function setupLocalScanner(){
    if(!connectBtn){
      return;
    }
    if(!('serial' in navigator)){
      connectBtn.disabled = true;
      connectBtn.title = 'Web Serial API is not supported in this browser.';
      return;
    }
    connectBtn.addEventListener('click', () => {
      connectLocalScanner();
    });
    if(navigator.serial.addEventListener){
      navigator.serial.addEventListener('disconnect', (event) => {
        if(localPort && event.target === localPort){
          localPort = null;
          localConnected = false;
          if(connectBtn){
            connectBtn.disabled = false;
            connectBtn.textContent = 'Connect Local Scanner';
          }
          showError('Local scanner disconnected');
        }
      });
    }
  }

  if(deepBtn){
    setDeepReadState(false, {updateStatus: false, clearDetails: false});
    deepBtn.addEventListener('click', async () => {
      const headers = {
        'Accept': 'application/json',
      };
      const csrf = getCookie('csrftoken');
      if(csrf){
        headers['X-CSRFToken'] = csrf;
      }
      deepBtn.disabled = true;
      try {
        const response = await fetch('{{ deep_read_url|default:"" }}', {
          method: 'POST',
          credentials: 'same-origin',
          headers,
        });
        if(!response.ok){
          throw new Error('Request failed');
        }
        const data = await response.json().catch(() => ({}));
        if(data.error){
          throw new Error(data.error);
        }
        const enabled = Boolean(data.enabled);
        setDeepReadState(enabled, {updateStatus: false});
        statusEl.textContent = data.status || (enabled ? 'Deep read enabled' : 'Deep read disabled');
      } catch(err){
        const message = err && err.message ? err.message : 'Deep read failed';
        statusEl.textContent = message;
      } finally {
        deepBtn.disabled = false;
      }
    });
  }
  setupLocalScanner();
  poll();
})();
</script>
{% endwith %}
